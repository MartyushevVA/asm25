bits 64
; Программа реализует сортировку кучей (Heap Sort) для массива 32-битных чисел.

section .data
n:
    dd 10  ; Количество элементов в массиве
mas:
    dd 8, 7, 1, 9, 5, 2, 6, 0, 4, 3  ; Сам массив чисел

section .text
global _start
_start:
    mov rbx, mas  ; Загружаем адрес массива в регистр rbx
    mov esi, [n]  ; Загружаем количество элементов в esi
    mov rdi, rsi  ; Копируем количество элементов в rdi
    dec rdi       ; Уменьшаем rdi на 1 (для работы с индексами)
    jle m8        ; Если количество элементов <= 1, завершаем программу

    shr rsi, 1    ; Делим количество элементов на 2 (начало построения кучи)
    
m1:
    or rsi, rsi   ; Проверяем, равно ли rsi нулю
    jnz m2        ; Если rsi != 0, переходим к m2
    cmp rdi, 1    ; Если rsi == 0, проверяем, остался ли один элемент
    jz m7         ; Если остался один элемент, переходим к m7

    ; Меняем первый и последний элементы местами
    mov eax, [rbx]        ; Загружаем первый элемент в eax
    xchg eax, [rbx+rdi*4] ; Меняем его с последним элементом
    mov [rbx], eax        ; Сохраняем новый первый элемент
    dec rdi               ; Уменьшаем количество неотсортированных элементов
    jmp m3                ; Переходим к m3

m2:
    dec rsi  ; Уменьшаем rsi (переходим к следующему элементу для построения кучи)

m3:
    mov eax, [rbx+rsi*4]  ; Загружаем текущий элемент в eax
    push rsi              ; Сохраняем текущий индекс в стеке
    mov rcx, rsi          ; Копируем индекс в rcx (начало просеивания вниз)

m4:
    shl rcx, 1  ; Умножаем индекс на 2 (переход к левому потомку)
    inc rcx     ; Увеличиваем индекс на 1 (переход к правому потомку)
    cmp rcx, rdi ; Сравниваем индекс с количеством неотсортированных элементов
    je m5        ; Если равен, переходим к m5
    jg m6        ; Если больше, переходим к m6

    ; Сравниваем левого и правого потомков
    mov edx, [rbx+rcx*4]      ; Загружаем левого потомка
    cmp edx, [rbx+rcx*4+4]    ; Сравниваем с правым потомком
    jge m5                    ; Если левый >= правого, переходим к m5
    inc rcx                   ; Иначе выбираем правого потомка

m5:
    ; Сравниваем текущий элемент с выбранным потомком
    cmp eax, [rbx+rcx*4]  ; Сравниваем текущий элемент с потомком
    jge m6                ; Если текущий >= потомка, переходим к m6

    ; Просеивание вниз: меняем текущий элемент с потомком
    mov edx, [rbx+rcx*4]  ; Загружаем потомка
    mov [rbx+rsi*4], edx  ; Сохраняем потомка на место текущего элемента
    mov rsi, rcx          ; Обновляем текущий индекс
    jmp m4                ; Продолжаем просеивание

m6:
    ; Завершение просеивания: сохраняем текущий элемент
    mov [rbx+rsi*4], eax  ; Сохраняем текущий элемент на его место
    pop rsi               ; Восстанавливаем индекс из стека
    jmp m1                ; Возвращаемся к началу цикла

m7:
    ; Сравниваем первый и второй элементы (последний шаг сортировки)
    mov eax, [rbx]        ; Загружаем первый элемент
    cmp eax, [rbx+4]      ; Сравниваем с вторым элементом
    jle m8                ; Если первый <= второго, завершаем
    xchg eax, [rbx+4]     ; Иначе меняем их местами
    mov [rbx], eax        ; Сохраняем новый первый элемент

m8:
    ; Завершение программы
    mov eax, 60  ; Системный вызов exit
    mov edi, 0   ; Код возврата 0
    syscall      ; Вызов системы